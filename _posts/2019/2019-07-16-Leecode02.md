---
layout:     post
title:      python Leecode 回文数+罗马数字转整数
subtitle:   Leecode
date:       2019-7-16
author:     maomaochen
header-img: img/post-bg-rwd.jpg
keywords_post:  "算法,Leecode,python"
catalog: true
tags:
    - 算法
    - python
    - Leecode
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head> 

## 1.回文数

**题目：**判断一个整数是否是回文数。回文数是正序和倒序读都是一样的整数。

> **示例：**
>
> $input:121$	$output:true$
>
> $input:-121$	$output:false$
>
> $input:10$	$output:false$

解法一：自己写的，将整数转化为字符串，通过字符串相等判断

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        wen=list(str(x))
        veswen = wen
        veswen.reverse()
        for i in range(len(wen)):
            if wen[i]!=veswen[-i-1]:
                return False
        return True
```

执行用时96ms，内存消耗13.3MB，提交结果通过

别人写的直接使用字符串切片，没有使用list，执行时间76ms，内存消耗13.4MB，提交结果通过：

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if str(x)[::] == str(x)[::-1]: 
            return True 
        else: 
            return False
```

解法二：进阶版，不将整数转为字符串解决

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0 or (x % 10 == 0 and x != 0) :
            return False
        revertedNumber = 0
        while x > revertedNumber:
            revertedNumber = revertedNumber * 10 + x % 10
            x = x // 10
        return x == revertedNumber or x == revertedNumber // 10
```

执行用时92ms，内存消耗13.3MB，提交结果通过

这个解法是**取出后半段数字进行翻转**，由于回文数位数可奇可偶，当长度为偶数时，对折过来应该是相等的；当长度为奇数时，对折过来后，有一个的长度需要去掉一位。

算法过程：

* 每次取余取出最低数字`x % 10`
* 最低数字加到取出是的尾部`revertedNumber = revertedNumber * 10 + x % 10`
* 每取一位，x都要自除`x = x // 10`
* 判断`x`是否小于`revertedNumber `，小于说明数字反转过半
* 判断奇偶情况，偶数则`x == revertedNumber`，奇数则`x == revertedNumber // 10`，因为中间数字在`revertedNumber`的末尾上

`if x < 0 or (x % 10 == 0 and x != 0)`先进行筛选，首先负数肯定不是回文数，能被0整除且不是0的数也肯定不是回文数。

## 2.罗马数字转整数









<br>

